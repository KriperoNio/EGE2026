# В целом задания несложные. Таблицы составляются просто. Единственное, могут возникнуть
# проблемы с 5 и более не заполненными элементами, тем более когда нет уникальности в
# таблице. (Например, в таблице только 0 в ячейках или 1)

# 2 подхода ПРОСТОЙ и СЛОЖНЫЙ

# ПРОСТОЙ
for x in [0,1]:
    for y in [0, 1]:
        for z in [0, 1]:
            for w in [0, 1]:
                if ((not(x <= z)) or (y == w) or y) == 0:
                    print(x, y, z, w)
# Из минусов: ручной анализ

# СЛОЖНЫЙ
from itertools import product, permutations # два импорта
def f (x, y, z, w): # наше условие
    return (x or y) and (not(y == z)) and (not w)

for a1, a2, a3, a4 in product([0,1], repeat=4): # генерация кортежей с элементами [0,1] длинной в repeat=4
    t = [(1, a1, 1, a2), (0, 1, a3, 0), (a4, 1, 1, 0)] # заполнение ими table (таблицу)
    if(len(t)) == len(set(t)): # теперь оптимизируем и выкидываем варианты с повторяющимися строчками
        for p in permutations('xyzw'): # генерируем комбинации ключей те столбиков
            if [f(**dict(zip(p, r))) for r in t] == [1, 1, 1]: # распаковываем t раз словари, составленные с помощью zip
                # по ключу p и строке row (те r), в список, задавая значение с помощью fun. И сравниваем полученный
                # список с нужными значениями.
                print(''.join(p))
# Из минусов: глубокое понимание и время написания(но часто это самый адекватный вариант)
